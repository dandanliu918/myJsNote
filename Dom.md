#Dom （documen object molder ）    ##一.DOM常用的获取方法      1.通过Dom的方法取回来的元素都是一个对象数据类型的       #####1.通过id获取元素     1. 只能通过document.getElementById来调用，其他的任何dom元素都不行     2 如果页面内不存在这个id默认获取回来的null     3 如果页面内存在两个相同的id那么默认获取第一个     4 在某些低版本ie浏览器name可能会当做id来用,name属性和id不要写成一样的     5 尽量不要写大小写不同的id          var div1 = document.getElementById('div1');            #####2.通过标签名获取元素    1 通过标签获取元素获取回来的是一组元素,即使这一组元素中只有一个li。也不会默认选中第一个，如果想获取通过索引值0来拿     2  这个方法是可以规定范围的，也就是在具体的某个范围内获取。比如div1.getElementsByTagName就是在div1这个范围内获取          var div1 = document.getElementById('div1'); //先获取到最外层的div1     var lis = div1.getElementsByTagName('li'); //获取div1这个范围内所有的li标签,div1可以理解为一个范围     console.log(lis); // 类数组：有length属性，有索引     #####3.通过类名获取元素  不兼容在IE6-8        1  和标签名一样类名字也可以出现多次，所以回来的也是一组元素。和标签一样也可以给规定范围，比如div1.getElementsByClassName('ul') 获取div1这个范围内所有类名为ul的。和其他没有关系             var uls = div1.getElementsByClassName('ul')[0]; //[ul]这才是拿到一组中的一个          console.log(uls);          #####4.通过name获取元素    1 一般应用于表单元素  input    2 在标准浏览器内给div添加了一个name属性虽然没用，但是可以通过name来获取元素，在ie9以下就不可以     var names = document.getElementsByName('name');         console.log(names.length);         #####5.获取html和body的方式： 都是标签可以通过标签名字来获取    html:  document.documentElement就是html    body:  document.body 就是body        获取浏览器可视窗口的宽度和高度     document.documentElement.clientWidth||document.body.clientWidth    document.documentElement.clientHeight||document.body.clientHeight     #####6.document.querySelector/document.querySelectorAll 适用于移动端      var  div1 =  document.querySelector('#div1');          console.log(div1);          var div1 = document.querySelectorAll('#div1 li');          console.log(div1);          var input = document.querySelectorAll('input[type=checkbox][name=hobby]');          console.log(input);            ##二.DOM元素的增删改查     #####1.appendChild 父级元素.appendChild(子集元素) 并且默认添加到末尾      div1.appendChild(p); //把刚刚创建的p标签添加到div1中,p是div1的最后一个子元素   #####2. insertBefore(要插入的元素,要插入到哪个元素的前面)      var span = document.createElement('span');         div1.insertBefore(span,ul1); //把刚刚创建的span标签插入到ul1前面，并且只能是父级元素div1来执行            #####3.removeChild 删除页面内的dom元素     div1.removeChild(ul1); //在div1内把ul移除掉   #####4.replaceChild(new,old)       var img = document.createElement('img');          div1.replaceChild(img,ul1);            #####5.要克隆的元素.cloneNode(true)     如果参数是true意思是把所有的子孙后代都带着一起克隆     var newDiv1 = div1.cloneNode(true); //克隆了一份div1     document.body.appendChild(newDiv1); //把刚刚克隆的div1添加到body末尾       #####6.document.createElement('div') 创建元素 一般和appendChild一起使用    ##三.DOM元素内的增加修改，删除，修改       setAttribute 设置属性     getAttribute  获取属性 如何获取的不存在 返回null     removeAttribute 移除属性      ##四.节点关系     node:节点的意思, 所有的元素，换行，注释，文本等都可以叫做节点    parentNode: 父节点    childNodes: 所有的子节点（有可能有注释，换行，文本，元素只是其中的一部分）    children:所有的元素(是元素)子节点, 不兼容        children兼容版本      function children（ele）{       var childNodes=ele.childNodes;       var ary=[];       for(var i=0;i<childNodes.length;i++){          var curNode=childrenNode[i];          if(curNode.nodeType==1){           ary.push(curNode)          }       }       return ary;      }                 ####节点和文本的关系                              元素div1       文本         注释          document                 nodeType(节点类型)     1          3           8             9               nodeName(节点名称)   大写标签名   #text      #comment     #document                 nodeValue(节点值)     null      文本内容     注释内容       null           ####节点关系        previousSibling  上一个哥哥节点(是节点)    previousElementSibling 上一个元素(是元素)哥哥节点  不兼容        兼容版本      function prevEleSibling(ele) {       var prev = ele.previousSibling;        while( prev && prev.nodeType !== 1){        prev = prev.previousSibling;        }                return prev;            }                            nextSibling  下一个弟弟节点 (是节点)    nextElementSibling 下一个元素弟弟节点(是元素) 不兼容            firstChild 第一个子节点(是节点)    firstElementChild 第一个元素子节点(是元素) 不兼容        lastChild 最后一个子节点(节点)    lastElementChild 最后一个元素子节点(是元素) 不兼容    ####使用while循环需要注意的几点    1,循环的条件移动要注意，不要写成死循环    2，写循环的时候，循环的条件注意更换或者迭代，保证循环的条件在不断迭代的过程中的终点值会出 现 false 而模拟prevEleSibling的时候，利用的是previousSibling总有一个时刻是null    