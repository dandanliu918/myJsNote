## Call（） 作用：改变this指向- call第一个参数：改变call点前面的函数中this指向- call的第二个参数开始，对函数中的形参从左往右的赋值  注意：call继承：把父类私有属性和方法，都继承给了子类私有的      注意：js中有严格模式和非严格模式区别'use strict'       1.call 方法中的this如果严格模式下即使是null和undefined 那么也直接使用，非严格模式下都是Window    2.如果call没有写参数，严格模式下undefined，非严格模式下是Window    3.在严格模式下自运行函数中的this是undefined，非严格模式下是window    4.在严格模式下函数执行时候如果'.'前面没有，那么this就undefined        call用法：    1.fn1.call（fn2） 最后是fn1执行    2.fn1.call.call.call.call(fn2) 最后就是fn2执行，如果fn2没有传一个函数那么久报错    ## apply（） 作用：改变this指向   - apply的第一个参数也是用来修改调用apply那个函数中的this的  - apply的第二个参数是一个数组，是把数组里的每一项当作参数分别传给调用apply的函数     ps:其实就是传参的方式不同。call是一个个的，apply是一个数组               function sum(num1,num2){            console.log(this);            console.log(num1 + num2);        }        sum(100,200); //window 300        sum.call(null,100,200); //window 300        sum.apply(document.body,[100,200]); // body 300         ### bind（）只改变this指向  - bind方法修改完this之后并不执行，只是返回一个已经修改过this的新函数  - bind方法的兼容是有问题，bind方法只是先处理了this然后返回一个新函数            var res = sum.bind(document.body);        console.log(res === sum); // false res就是修改过this的新函数        res(300,400); // 700    