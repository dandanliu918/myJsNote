###数组 Array  1.length 天生自带的属性，记录当前这个数组里有多少项      length-- 可以吧数组的最后一项删除    length++ 可以在数组的末尾添加一个undefined    ary[ary.length] 向数组的末尾添加一项     ####数组的方法    #####1.push      1 向数组末尾添加项    2 参数就是要增加的项    3 返回值是数组的新长度    4 原有数组改变(增加了项目)    ps: 如果在末尾增加多项那么就在参数位置用逗号隔开        #####2.unshift            1 向数组的开头增加项    2 参数是要增加的数组项目，如果是多个用","隔开    3 数组的新长度    4 原有数组改变      #####3.pop      1 删除数组的末尾项     2 不用参数，就是删除最后一个     3 返回值是删除的最后一项(可不是新长度)     4 原有数组改变 ######4.shift     1 删除数组的开头项     2 不用参数     3 返回值是删除的第一项     4 原有数组改变  ######5.splice    1 删除数组项可以指定具体的哪些项    2 splice(n,m) 从索引n开始删除m个          splice(n) 如果第二个参数没有写那么就是从n索引开始删除到末尾          splice(0)  从第一项开始删一直到末尾          splice(n,m,x,y) 从索引n开始删除m个，然后用x,y去顶替删除的位置,从第三个参数开始都是用来填补删除的项目位置的          pop => splice(ary.length-1,1); 从最后一项的索引开始删除1个          shift => splice(0,1) 从索引0开始删除1个          unshift => splice(0,0,'tianxi') 从索引0开始一个都不删，然后把'tianxi'字符串添加到第一个索引0的前面          push => splice(ary.length,0,'tianxi')    3 返回值是删除的数组项目组合成新数组    4 原有数组改变    #####6.slice      1 用来复制数组      2  slice(n,m) 从索引n开始复制到索引m，但是不包含m(其实也就是复制到m-1)         slice(n)   从索引n开始复制到末尾         slice(0)   从开头复制到末尾  克隆数组         slice()    从开头复制到末尾 克隆数组      3 返回值是新复制的数组      4 原有数组不改变      #####7.concat 拼接    1 把两个或者两个以上的数组拼接在一起    2 参数: 你要拼接的数组或者数组项目，如果是多个请用","隔开    3 返回值: 拼接好的新数组    4 原有数组不变    #####8.join       1 把数组里的每一项按照指定的分隔符拼接成字符串       2 参数就是指定的分隔符,如果没有指定参数那么默认就是逗号       3 返回值是拼接好的字符串       4 原有数组不变       eval: 可以把字符串当做js代码运行 ,去掉引号的作用   eval('1+2+3') => 6       #####9.reverse 排序        1 倒序数组     2 不用参数     3 返回值是经过倒序过后的原有数组(记住是原有数组)     4 原有数组顺序改变     #####10.sort        1 是把数组按照指定规则去排序  规则： 升序 降序      2 参数就是规则：这个规则是一个函数 => sort的参数是一个函数      ps: 如果不加参数只能排序10以内的      3 返回值:排好序的原有数组      4 原有数组顺序改变             function sort（a,b）{       return  a-b       }       #####11.indexOf/lastIndexOf       1 判断一个项是否在数组中出现过=> 数组中是否包含这个项       2 参数：需要判断是否在数组出现的那个项       3 返回值: 如果出现过那么就返回出现的位置(索引值),如果没有出现过那么就返回-1       4 原有数组不变       #####12.forEach    1 循环遍历数组的每一项的    2  参数也是一个函数: 这个函数还有三个形参分别是item,index,ary，其中item是循环的时候的每一项，index是每一项的索引，ary是原有数组    3 返回值是undefined。只是遍历数组没有必要返回任何值    4 原有数组不变        forEach封装      var ary=[12,34,52,28];          var obj={};          //1.forEach应该挂在原型上          //2.forEach有两个参数          //3.forEach没有返回值，所以，我们不需要接收回调函数的返回值；          Array.prototype.myForEach=function(cb,context){              var context=context||window;              //当浏览器支持的时候，直接使用浏览器提供的方法              if('forEach' in Array.prototype){                  this.forEach(cb,context);                  return;//阻断程序执行的作用；              }              //当浏览器不支持，自己做兼容处理；              for(var i=0; i<this.length; i++){                  cb.call(context,this[i],i,this);              }          }          var res=ary.myForEach(function(item,index,input){              console.log(this===obj)          },obj)          console.log(res)    #####13.map    1 作用和forEach的用法基本相同，都是遍历数组。但是map有返回值    2 参数: 参数仍然是一个函数，并且还有形参item,index,ary代表的意思和forEach也是一样的。    3 返回值: 是一个数组，并且这个数组和原有数组的长度是相同的，但是数组里的每一项是传进来函数参数每次运行的返回值。也就是return后面的值。其实也就是参数每次执行的结果    4 原有数组不变        map封装     var ary=[12,34,52,28];        var obj={};        //1.forEach应该挂在原型上        //2.forEach有两个参数        //3.forEach没有返回值，所以，我们不需要接收回调函数的返回值；        Array.prototype.myMap=function(cb,context){            context=context||window;            //当浏览器支持的时候，直接使用浏览器提供的方法            if('map' in Array.prototype){                return this.map(cb,context);            }            //当浏览器不支持，自己做兼容处理；            var ary=[];//这个数组是为了接收每个回调函数的返回值；            for(var i=0; i<this.length; i++){                var res=cb.call(context,this[i],i,this);                ary.push(res);            }            return ary;        }        var res=ary.myMap(function(item,index,input){            console.log(this===obj)            return item*10        },obj)        console.log(res)